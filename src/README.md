# Firebase Studio

This is a NextJS starter in Firebase Studio.

To get started, take a look at src/app/page.tsx.

## Supabase Setup (Optional)

If you wish to use Supabase for data persistence, follow these steps:

1.  **Create a Supabase Project**: Go to [supabase.com](https://supabase.com) and create a new project.

2.  **Get API Credentials**: In your Supabase project dashboard, navigate to **Project Settings** > **API**. You will find your **Project URL** and your **anon (public) key**.

3.  **Set Environment Variables**: Create a `.env` file in the root of this project (if it doesn't exist) and add your credentials:
    ```
    NEXT_PUBLIC_SUPABASE_URL=YOUR_PROJECT_URL
    NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_ANON_KEY
    ```

4.  **Create Database Tables**: Go to the **SQL Editor** in your Supabase dashboard and run the following SQL queries to create the necessary tables.

    **Table for Market Summary Data:**
    ```sql
    CREATE TABLE IF NOT EXISTS market_summary_data (
        pair TEXT PRIMARY KEY,
        price REAL NOT NULL,
        change REAL NOT NULL,
        volume REAL NOT NULL,
        high REAL NOT NULL,
        low REAL NOT NULL,
        icon TEXT,
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    ```

    **Table for K-Line (OHLC) Data:**
    ```sql
    CREATE TABLE IF NOT EXISTS market_kline_data (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        trading_pair TEXT NOT NULL,
        time BIGINT NOT NULL, -- Changed from TIMESTAMPTZ to BIGINT
        open REAL NOT NULL,
        high REAL NOT NULL,
        low REAL NOT NULL,
        close REAL NOT NULL
    );

    -- Create an index for faster time-based queries
    CREATE INDEX IF NOT EXISTS idx_market_kline_data_time ON market_kline_data(time DESC);
    CREATE INDEX IF NOT EXISTS idx_market_kline_data_pair_time ON market_kline_data(trading_pair, time DESC);
    ```

    **NOTE:** If you created the `market_kline_data` table before, you will need to alter its `time` column with this command:
    ```sql
    ALTER TABLE market_kline_data
    ALTER COLUMN time TYPE BIGINT;
    ```
    
    **Enable Read Access for K-Line Data**: Run the following SQL to allow the application to read the public K-line data.
    ```sql
    -- If RLS is not enabled, enable it first
    ALTER TABLE market_kline_data ENABLE ROW LEVEL SECURITY;

    -- Create a policy that allows public read access to everyone
    CREATE POLICY "Allow public read access to kline data"
    ON market_kline_data
    FOR SELECT
    USING (true);
    ```
    
    **Table for Reward Logs:**
    ```sql
    CREATE TABLE IF NOT EXISTS reward_logs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id TEXT NOT NULL,
        type TEXT NOT NULL, -- 'dailyTask', 'team', 'event', or 'system'
        amount REAL NOT NULL,
        source_id TEXT,
        description TEXT,
        created_at BIGINT DEFAULT EXTRACT(EPOCH FROM NOW())::BIGINT
    );

    CREATE INDEX IF NOT EXISTS idx_reward_logs_user ON reward_logs(user_id);
    CREATE INDEX IF NOT EXISTS idx_reward_logs_type ON reward_logs(type);
    ```

     **Table for Options Contracts:**
    ```sql
    CREATE TABLE IF NOT EXISTS options_contracts (
        contract_id TEXT PRIMARY KEY,
        underlying_symbol TEXT NOT NULL,
        expiration_date DATE NOT NULL,
        type TEXT NOT NULL, -- 'call' or 'put'
        strike_price REAL NOT NULL,
        last_price REAL,
        bid REAL,
        ask REAL,
        change REAL,
        change_percent REAL,
        volume INTEGER,
        open_interest INTEGER,
        implied_volatility REAL,
        in_the_money BOOLEAN,
        delta REAL,
        gamma REAL,
        theta REAL,
        vega REAL,
        rho REAL,
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_options_contracts_symbol_expiry ON options_contracts(underlying_symbol, expiration_date);
    ```

    **Table for Market Intervention Rules:**
    ```sql
    CREATE TABLE market_interventions (
      id bigint primary key generated always as identity,
      trading_pair text not null,
      start_time timestamptz not null,
      end_time timestamptz not null,
      rule jsonb not null,  -- e.g. { "priceMultiplier": 1.05, "volumeOffset": 200, "forceValue": 66666 }
      created_at timestamptz default now()
    );
    ```

## 生产级行情架构 (Production Architecture)

为了减少前端负载、增强数据一致性并实现更可靠的干预逻辑，我们设计了以下生产级架构。该架构将数据处理和调度任务迁移到后端。

### 1. 数据流

1.  **外部 API 拉取**: 一个后端的定时任务（如 Node.js Cron Job 或 Supabase Edge Function）负责从外部 API（Tatum, Alpha Vantage 等）拉取实时行情数据。
2.  **原始数据存储**: 拉取到的原始、未经修改的数据被存入一个“原始表” (`raw_market_data`)。此表仅作为数据备份和处理源，不直接对用户端暴露。
3.  **延迟与干预处理**:
    *   另一个后端延迟处理任务会定时（例如，每秒）运行。
    *   该任务读取 `raw_market_data` 中已经超过设定延迟时间（如 30 秒）的数据。
    *   在准备写入最终数据表前，任务会查询 `market_interventions` 表，检查当前时间是否有生效的干预规则。
    *   如果存在干预规则，则根据规则（如价格乘数、强制设定值等）修改数据。
    *   如果不存在规则，则保持数据不变。
4.  **写入模拟数据表**: 经过延迟和干预逻辑处理后的“最终数据”被写入 `simulated_market_data` 表 (即我们现有的 `market_kline_data` 和 `market_summary_data` 表)。
5.  **用户端展示**: 用户的前端应用只从 `simulated_market_data` 表中读取数据。可以通过 Supabase Realtime 订阅数据变更，实现实时更新。

### 2. 优势

*   **前端轻量化**: 前端不再负责行情模拟、API 轮询和干预逻辑计算，只负责展示数据，极大降低了客户端的性能开销。
*   **数据一致性与公平性**: 所有用户看到的数据都来自同一个经过处理的数据库源，保证了行情的绝对一致。
*   **可靠的干预**: 干预逻辑在服务器端执行，与数据写入流程紧密结合，保证了干预的精确性和可靠性。
*   **数据存档**: 原始的、未被修改的真实市场数据被保存在 `raw_market_data` 表中，便于未来进行数据分析、调试和回溯。
