--
-- Migration for "Market Prediction" (市场预测) Task (FIXED)
--

-- Step 1: Create a table to store user predictions.
CREATE TABLE IF NOT EXISTS public.market_predictions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES public.users(id),
    symbol TEXT NOT NULL, -- e.g., 'BTC/USDT'
    prediction TEXT NOT NULL CHECK (prediction IN ('up', 'down')),
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'expired')),
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '24 hours' NOT NULL
);
COMMENT ON TABLE public.market_predictions IS 'Stores user predictions for the market prediction task.';

-- Step 1.1: Create a partial unique index to ensure a user can only have one pending prediction.
-- This is the corrected way to implement the unique constraint with a condition.
CREATE UNIQUE INDEX IF NOT EXISTS market_predictions_user_id_pending_status_idx
ON public.market_predictions(user_id)
WHERE (status = 'pending');

-- Step 1.2: Enable RLS and define policies.
ALTER TABLE public.market_predictions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to manage their own predictions" ON public.market_predictions
    FOR ALL USING (auth.uid() = user_id);

-- Step 2: Create a function for a user to start a prediction task.
CREATE OR REPLACE FUNCTION public.create_market_prediction(p_symbol TEXT, p_prediction TEXT)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_new_prediction_id BIGINT;
BEGIN
    -- Insert a new prediction. The unique index will automatically prevent
    -- creating a new 'pending' one if one already exists.
    INSERT INTO market_predictions (user_id, symbol, prediction)
    VALUES (auth.uid(), p_symbol, p_prediction)
    RETURNING id INTO v_new_prediction_id;

    RETURN jsonb_build_object(
        'success', true,
        'message', 'Prediction created successfully.',
        'prediction_id', v_new_prediction_id
    );
EXCEPTION
    WHEN unique_violation THEN
        RAISE EXCEPTION '您当前有一个还未完成的预测任务。';
END;
$$;

-- Step 3: Create the function to claim the reward after completing the task.
-- ASSUMPTION: A `transactions` table exists with `user_id`, `symbol`, `type` ('buy', 'sell'), and `amount_usd`.
CREATE OR REPLACE FUNCTION public.claim_market_prediction_reward()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_user_id UUID := auth.uid();
    v_wallet_id UUID;
    v_pending_prediction RECORD;
    v_has_buy_tx BOOLEAN;
    v_has_sell_tx BOOLEAN;
    v_min_trade_amount NUMERIC := 10.00; -- Minimum trade size is 10 USDT
    v_reward_amount NUMERIC := 3.00; -- Reward is 3 USDT
BEGIN
    -- Find the user's pending prediction
    SELECT * INTO v_pending_prediction FROM market_predictions
    WHERE user_id = v_user_id AND status = 'pending' AND now() < expires_at;

    IF v_pending_prediction IS NULL THEN
        RAISE EXCEPTION '您没有有效的、正在等待完成的预测任务。';
    END IF;

    -- Check if the reward has already been claimed for this task type recently.
    -- This is a safety net; the primary check is the 'pending' status.
    IF EXISTS (SELECT 1 FROM user_rewards WHERE user_id = v_user_id AND reward_type = 'market_prediction_success' AND claimed_at > v_pending_prediction.created_at) THEN
        RAISE EXCEPTION '您最近已经领取过市场预测任务的奖励了。';
    END IF;

    -- Check for a qualifying 'buy' transaction since the prediction was made.
    SELECT EXISTS (SELECT 1 FROM transactions WHERE
        user_id = v_user_id AND
        type = 'buy' AND
        symbol = v_pending_prediction.symbol AND
        created_at >= v_pending_prediction.created_at AND
        amount_usd >= v_min_trade_amount
    ) INTO v_has_buy_tx;

    -- Check for a qualifying 'sell' transaction.
    SELECT EXISTS (SELECT 1 FROM transactions WHERE
        user_id = v_user_id AND
        type = 'sell' AND
        symbol = v_pending_prediction.symbol AND
        created_at >= v_pending_prediction.created_at AND
        amount_usd >= v_min_trade_amount
    ) INTO v_has_sell_tx;

    IF NOT (v_has_buy_tx AND v_has_sell_tx) THEN
        RAISE EXCEPTION '任务未完成：您需要在此次预测后，完成一笔买入和一笔卖出交易（均不少于 % USDT）。', v_min_trade_amount;
    END IF;

    -- All checks passed, grant the reward.
    SELECT id INTO v_wallet_id FROM wallets WHERE user_id = v_user_id;
    IF v_wallet_id IS NULL THEN RAISE EXCEPTION '用户钱包不存在。'; END IF;

    UPDATE wallets SET balance = balance + v_reward_amount WHERE id = v_wallet_id;

    -- Update prediction status to 'completed'
    UPDATE market_predictions SET status = 'completed' WHERE id = v_pending_prediction.id;

    -- Record the reward
    INSERT INTO user_rewards (user_id, reward_type, amount_awarded, details)
    VALUES (v_user_id, 'market_prediction_success', v_reward_amount, jsonb_build_object('prediction_id', v_pending_prediction.id));

    -- Log the action
    INSERT INTO action_logs (user_id, action_type, details)
    VALUES (v_user_id, 'reward_claim', jsonb_build_object('reward_type', 'market_prediction_success', 'amount', v_reward_amount));

    RETURN jsonb_build_object('success', true, 'message', '任务完成！成功领取 ' || v_reward_amount || ' USDT 奖励！');
END;
$$;
