
-- 1. UTILITY FUNCTIONS
-- Function to update the `updated_at` timestamp on any table with the column.
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 2. SCHEMA AND TABLES
-- Create the main tables for the application.

-- USERS Table: Stores user profile information.
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
    username text UNIQUE NOT NULL,
    nickname text,
    email text UNIQUE NOT NULL,
    avatar_url text,
    inviter_id uuid REFERENCES public.profiles(id),
    is_admin boolean DEFAULT false,
    is_test_user boolean DEFAULT false,
    is_frozen boolean DEFAULT false,
    invitation_code text UNIQUE,
    credit_score integer DEFAULT 100,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    last_login_at timestamp with time zone,
    CONSTRAINT username_length CHECK (char_length(username) >= 3 AND char_length(username) <= 50)
);
COMMENT ON TABLE public.profiles IS 'Stores user public profile information.';

-- BALANCES Table: Stores asset balances for each user.
CREATE TABLE IF NOT EXISTS public.balances (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id uuid NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
    asset text NOT NULL,
    available_balance numeric NOT NULL DEFAULT 0,
    frozen_balance numeric NOT NULL DEFAULT 0,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    UNIQUE(user_id, asset)
);
COMMENT ON TABLE public.balances IS 'Stores asset balances for each user.';

-- TRADES Table: Records all spot and contract trades.
CREATE TABLE IF NOT EXISTS public.trades (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
    trading_pair text NOT NULL,
    orderType text NOT NULL, -- 'spot' or 'contract'
    type text NOT NULL, -- 'buy' or 'sell'
    status text NOT NULL, -- 'active', 'settled', 'filled', 'cancelled'
    amount numeric, -- For contract trades, the investment amount; for spot, the base asset amount
    total numeric, -- For spot trades, the quote asset total
    price numeric, -- For spot trades
    entry_price numeric, -- For contract trades
    settlement_price numeric,
    period integer, -- For contract trades (in seconds)
    profit_rate numeric,
    outcome text, -- 'win' or 'loss'
    profit numeric,
    base_asset text,
    quote_asset text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    settlement_time timestamp with time zone
);
COMMENT ON TABLE public.trades IS 'Records all spot and contract trades.';

-- REQUESTS Table: For deposits, withdrawals, password resets etc.
CREATE TABLE IF NOT EXISTS public.requests (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
    type text NOT NULL, -- 'deposit', 'withdrawal', 'password_reset'
    asset text,
    amount numeric,
    address text,
    transaction_hash text,
    new_password text,
    status text NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
COMMENT ON TABLE public.requests IS 'User requests for deposits, withdrawals, etc.';

-- INVESTMENTS Table: Records user investments in financial products.
CREATE TABLE IF NOT EXISTS public.investments (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
    product_name text NOT NULL,
    amount numeric NOT NULL,
    status text NOT NULL, -- 'active', 'settled'
    profit numeric,
    category text,
    productType text, -- 'daily', 'hourly'
    daily_rate numeric,
    period integer, -- days
    hourly_rate numeric,
    duration_hours integer,
    stakingAsset text,
    stakingAmount numeric,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    settlement_date timestamp with time zone NOT NULL
);
COMMENT ON TABLE public.investments IS 'User investments in financial products.';

-- REWARD_LOGS Table: Records all commissions and rewards.
CREATE TABLE IF NOT EXISTS public.reward_logs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
    type text NOT NULL, -- 'dailyTask', 'team', 'event', 'system'
    amount numeric NOT NULL,
    asset text NOT NULL,
    source_id text,
    source_username text,
    source_level integer,
    description text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
COMMENT ON TABLE public.reward_logs IS 'Logs for commissions and other rewards.';

-- DAILY_TASKS Table: Admin-defined daily tasks.
CREATE TABLE IF NOT EXISTS public.daily_tasks (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    title text NOT NULL,
    description text,
    reward numeric NOT NULL,
    reward_type text NOT NULL, -- 'usdt' or 'credit_score'
    link text,
    imgSrc text,
    status text NOT NULL, -- 'published' or 'draft'
    trigger text NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
COMMENT ON TABLE public.daily_tasks IS 'Admin-defined daily tasks for users.';

-- USER_TASK_STATES Table: Tracks user task completion.
CREATE TABLE IF NOT EXISTS public.user_task_states (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id uuid NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
    taskId uuid NOT NULL REFERENCES public.daily_tasks ON DELETE CASCADE,
    date date NOT NULL,
    completed boolean DEFAULT false,
    UNIQUE(user_id, taskId, date)
);
COMMENT ON TABLE public.user_task_states IS 'Tracks user completion of daily tasks.';

-- ACTIVITIES Table: Admin-defined limited-time activities.
CREATE TABLE IF NOT EXISTS public.activities (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    title text NOT NULL,
    description text,
    rewardRule text,
    howToClaim text,
    expiresAt timestamp with time zone NOT NULL,
    imgSrc text,
    status text NOT NULL, -- 'published', 'draft'
    createdAt timestamp with time zone DEFAULT timezone('utc'::text, now())
);
COMMENT ON TABLE public.activities IS 'Admin-defined limited-time activities.';

-- ANNOUNCEMENTS Table: For platform-wide and personal announcements.
CREATE TABLE IF NOT EXISTS public.announcements (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    type text NOT NULL, -- 'personal_message', 'carousel', 'horn'
    user_id uuid REFERENCES public.profiles(id),
    title text,
    content jsonb,
    theme text,
    priority integer,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    UNIQUE(type)
);
COMMENT ON TABLE public.announcements IS 'Platform and user announcements.';

-- INVESTMENT_PRODUCTS Table: Admin-defined investment products.
CREATE TABLE IF NOT EXISTS public.investment_products (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL,
    price numeric NOT NULL,
    dailyRate numeric,
    period integer,
    maxPurchase integer NOT NULL,
    imgSrc text,
    category text NOT NULL,
    productType text,
    activeStartTime text,
    activeEndTime text,
    hourlyTiers jsonb,
    stakingAsset text,
    stakingAmount numeric
);
COMMENT ON TABLE public.investment_products IS 'Admin-defined investment products.';

-- ACTION_LOGS Table: Records admin actions.
CREATE TABLE IF NOT EXISTS public.action_logs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_type text,
    entity_id text,
    action text,
    operator_id uuid,
    operator_username text,
    details text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
COMMENT ON TABLE public.action_logs IS 'Records admin actions for auditing.';

-- SWAP_ORDERS Table: For P2P asset swaps.
CREATE TABLE IF NOT EXISTS public.swap_orders (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES public.profiles(id),
    username text,
    from_asset text NOT NULL,
    from_amount numeric NOT NULL,
    to_asset text NOT NULL,
    to_amount numeric NOT NULL,
    status text NOT NULL, -- 'open', 'pending_payment', ...
    taker_id uuid,
    taker_username text,
    payment_proof_url text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
COMMENT ON TABLE public.swap_orders IS 'Stores P2P swap orders.';

-- MARKET DATA Tables
CREATE TABLE IF NOT EXISTS public.market_summary_data (
    pair text PRIMARY KEY,
    price numeric,
    change numeric,
    volume numeric,
    high numeric,
    low numeric,
    icon text,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
COMMENT ON TABLE public.market_summary_data IS 'Stores latest summary data for all pairs.';

CREATE TABLE IF NOT EXISTS public.market_kline_data (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    trading_pair text NOT NULL,
    time timestamp with time zone NOT NULL,
    open numeric,
    high numeric,
    low numeric,
    close numeric,
    UNIQUE(trading_pair, time)
);
COMMENT ON TABLE public.market_kline_data IS 'Stores OHLC k-line data.';

CREATE TABLE IF NOT EXISTS public.system_settings (
    id integer PRIMARY KEY,
    settings jsonb,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
COMMENT ON TABLE public.system_settings IS 'Stores all global system settings.';

-- 3. TRIGGERS
-- Trigger to automatically update `updated_at` on tables.
CREATE OR REPLACE TRIGGER on_profiles_update
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

CREATE OR REPLACE TRIGGER on_requests_update
  BEFORE UPDATE ON public.requests
  FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

CREATE OR REPLACE TRIGGER on_balances_update
  BEFORE UPDATE ON public.balances
  FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
  
CREATE OR REPLACE TRIGGER on_daily_tasks_update
  BEFORE UPDATE ON public.daily_tasks
  FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
  
CREATE OR REPLACE TRIGGER on_market_summary_update
  BEFORE UPDATE ON public.market_summary_data
  FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
  
CREATE OR REPLACE TRIGGER on_system_settings_update
  BEFORE UPDATE ON public.system_settings
  FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- Trigger to create a profile when a new user signs up.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, nickname, email, invitation_code, is_test_user, inviter_id, credit_score, avatar_url)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'username',
    NEW.raw_user_meta_data->>'nickname',
    NEW.email,
    NEW.raw_user_meta_data->>'invitation_code',
    (NEW.raw_user_meta_data->>'is_test_user')::boolean,
    (NEW.raw_user_meta_data->>'inviter_id')::uuid,
    (NEW.raw_user_meta_data->>'credit_score')::integer,
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger to avoid conflicts
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
-- Create the trigger
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 4. DATABASE FUNCTIONS

-- Function to get a user's downline (recursive)
DROP FUNCTION IF EXISTS public.get_downline(uuid);
CREATE OR REPLACE FUNCTION public.get_downline(p_user_id uuid)
RETURNS TABLE(id uuid, username text, nickname text, email text, inviter_id uuid, is_admin boolean, is_test_user boolean, is_frozen boolean, invitation_code text, credit_score integer, created_at timestamp with time zone, last_login_at timestamp with time zone, avatar_url text, level int) AS $$
BEGIN
  RETURN QUERY
  WITH RECURSIVE downline_cte AS (
    SELECT p.id, p.username, p.nickname, p.email, p.inviter_id, p.is_admin, p.is_test_user, p.is_frozen, p.invitation_code, p.credit_score, p.created_at, p.last_login_at, p.avatar_url, 1 as level
    FROM public.profiles p
    WHERE p.inviter_id = p_user_id
    UNION ALL
    SELECT p.id, p.username, p.nickname, p.email, p.inviter_id, p.is_admin, p.is_test_user, p.is_frozen, p.invitation_code, p.credit_score, p.created_at, p.last_login_at, p.avatar_url, d.level + 1
    FROM public.profiles p
    JOIN downline_cte d ON p.inviter_id = d.id
    WHERE d.level < 3
  )
  SELECT * FROM downline_cte;
END;
$$ LANGUAGE plpgsql;

-- Function to adjust user balance
CREATE OR REPLACE FUNCTION public.adjust_balance(p_user_id uuid, p_asset text, p_amount numeric, p_is_frozen boolean DEFAULT false)
RETURNS void AS $$
BEGIN
  IF p_is_frozen THEN
    INSERT INTO public.balances (user_id, asset, frozen_balance)
    VALUES (p_user_id, p_asset, p_amount)
    ON CONFLICT (user_id, asset)
    DO UPDATE SET frozen_balance = public.balances.frozen_balance + p_amount;
  ELSE
    INSERT INTO public.balances (user_id, asset, available_balance)
    VALUES (p_user_id, p_asset, p_amount)
    ON CONFLICT (user_id, asset)
    DO UPDATE SET available_balance = public.balances.available_balance + p_amount;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to get total platform balance
CREATE OR REPLACE FUNCTION public.get_total_platform_balance()
RETURNS numeric AS $$
DECLARE
  total_balance numeric;
BEGIN
  SELECT COALESCE(sum(available_balance), 0)
  INTO total_balance
  FROM public.balances
  WHERE asset = 'USDT';
  RETURN total_balance;
END;
$$ LANGUAGE plpgsql;

-- Server-side settlement function
DROP FUNCTION IF EXISTS public.settle_due_records();
CREATE OR REPLACE FUNCTION public.settle_due_records()
RETURNS void AS $$
DECLARE
    trade_record RECORD;
    investment_record RECORD;
    settlement_price numeric;
    profit numeric;
    total_return numeric;
BEGIN
    -- Settle due contract trades
    FOR trade_record IN
        SELECT * FROM public.trades
        WHERE status = 'active' AND settlement_time <= now()
        FOR UPDATE
    LOOP
        -- Get the latest price for the pair
        SELECT price INTO settlement_price
        FROM public.market_summary_data
        WHERE pair = trade_record.trading_pair;
        
        -- If no price found, skip settlement for this trade
        IF settlement_price IS NULL THEN
            CONTINUE;
        END IF;

        -- Calculate profit
        IF trade_record.type = 'buy' THEN
            profit := CASE WHEN settlement_price > trade_record.entry_price THEN trade_record.amount * trade_record.profit_rate ELSE -trade_record.amount END;
        ELSE -- 'sell'
            profit := CASE WHEN settlement_price < trade_record.entry_price THEN trade_record.amount * trade_record.profit_rate ELSE -trade_record.amount END;
        END IF;

        -- Update trade record
        UPDATE public.trades
        SET status = 'settled',
            outcome = CASE WHEN profit > 0 THEN 'win' ELSE 'loss' END,
            profit = profit,
            settlement_price = settlement_price
        WHERE id = trade_record.id;

        -- Unfreeze and credit balance
        PERFORM public.adjust_balance(trade_record.user_id, trade_record.quote_asset, -trade_record.amount, true); -- Unfreeze
        IF profit >= 0 THEN
            PERFORM public.adjust_balance(trade_record.user_id, trade_record.quote_asset, trade_record.amount + profit, false); -- Return principal + profit
        END IF;
    END LOOP;

    -- Settle due investments
    FOR investment_record IN
        SELECT * FROM public.investments
        WHERE status = 'active' AND settlement_date <= now()
        FOR UPDATE
    LOOP
        -- Calculate profit based on product type
        IF investment_record.productType = 'daily' THEN
            profit := investment_record.amount * investment_record.daily_rate * investment_record.period;
        ELSIF investment_record.productType = 'hourly' THEN
            profit := investment_record.amount * investment_record.hourly_rate;
        ELSE
            profit := 0;
        END IF;

        total_return := investment_record.amount + profit;

        -- Update investment record
        UPDATE public.investments
        SET status = 'settled',
            profit = profit
        WHERE id = investment_record.id;

        -- Credit balance
        PERFORM public.adjust_balance(investment_record.user_id, 'USDT', total_return, false);
        
        -- Unfreeze staked asset if any
        IF investment_record.stakingAsset IS NOT NULL AND investment_record.stakingAmount IS NOT NULL THEN
            PERFORM public.adjust_balance(investment_record.user_id, investment_record.stakingAsset, -investment_record.stakingAmount, true); -- Unfreeze
            PERFORM public.adjust_balance(investment_record.user_id, investment_record.stakingAsset, investment_record.stakingAmount, false); -- Return to available
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 5. INDEXES
-- Create indexes for frequently queried columns to improve performance.
CREATE INDEX IF NOT EXISTS idx_profiles_inviter_id ON public.profiles(inviter_id);
CREATE INDEX IF NOT EXISTS idx_balances_user_id ON public.balances(user_id);
CREATE INDEX IF NOT EXISTS idx_trades_user_id ON public.trades(user_id);
CREATE INDEX IF NOT EXISTS idx_trades_status ON public.trades(status);
CREATE INDEX IF NOT EXISTS idx_requests_user_id ON public.requests(user_id);
CREATE INDEX IF NOT EXISTS idx_requests_status ON public.requests(status);
CREATE INDEX IF NOT EXISTS idx_investments_user_id ON public.investments(user_id);
CREATE INDEX IF NOT EXISTS idx_investments_status ON public.investments(status);
CREATE INDEX IF NOT EXISTS idx_reward_logs_user_id ON public.reward_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_user_task_states_user_id ON public.user_task_states(user_id);
CREATE INDEX IF NOT EXISTS idx_swap_orders_user_id ON public.swap_orders(user_id);
CREATE INDEX IF NOT EXISTS idx_swap_orders_status ON public.swap_orders(status);
CREATE INDEX IF NOT EXISTS idx_market_kline_data_pair_time ON public.market_kline_data(trading_pair, time DESC);


-- 6. SECURITY FUNCTION FOR RLS
-- A helper function to check if the current user is an admin.
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean AS $$
DECLARE
    is_admin_user boolean;
BEGIN
    SELECT is_admin
    INTO is_admin_user
    FROM public.profiles
    WHERE id = auth.uid();
    RETURN COALESCE(is_admin_user, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 7. ROW-LEVEL SECURITY (RLS)
-- Enable RLS for all tables that store user-specific data.
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.balances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trades ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.investments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reward_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_task_states ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.swap_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.activities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.announcements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.investment_products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.action_logs ENABLE ROW LEVEL SECURITY;

-- Drop existing policies before creating new ones to avoid conflicts.
DROP POLICY IF EXISTS "Allow all access for admins" ON public.profiles;
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Allow all access for admins" ON public.balances;
DROP POLICY IF EXISTS "Users can view their own balances" ON public.balances;
DROP POLICY IF EXISTS "Allow all access for admins" ON public.trades;
DROP POLICY IF EXISTS "Users can view their own trades" ON public.trades;
DROP POLICY IF EXISTS "Allow all access for admins" ON public.requests;
DROP POLICY IF EXISTS "Users can manage their own requests" ON public.requests;
DROP POLICY IF EXISTS "Allow all access for admins" ON public.investments;
DROP POLICY IF EXISTS "Users can view their own investments" ON public.investments;
DROP POLICY IF EXISTS "Allow all access for admins" ON public.reward_logs;
DROP POLICY IF EXISTS "Users can view their own reward logs" ON public.reward_logs;
DROP POLICY IF EXISTS "Allow all access for admins" ON public.user_task_states;
DROP POLICY IF EXISTS "Users can manage their own task states" ON public.user_task_states;
DROP POLICY IF EXISTS "Allow all access for admins" ON public.swap_orders;
DROP POLICY IF EXISTS "Users can manage their own swap orders" ON public.swap_orders;
DROP POLICY IF EXISTS "Users can view open swap orders" ON public.swap_orders;
DROP POLICY IF EXISTS "Allow admin access to content tables" ON public.daily_tasks;
DROP POLICY IF EXISTS "Allow public read access" ON public.daily_tasks;
DROP POLICY IF EXISTS "Allow admin access to content tables" ON public.activities;
DROP POLICY IF EXISTS "Allow public read access" ON public.activities;
DROP POLICY IF EXISTS "Allow admin access to content tables" ON public.announcements;
DROP POLICY IF EXISTS "Allow public read access" ON public.announcements;
DROP POLICY IF EXISTS "Allow admin access to content tables" ON public.investment_products;
DROP POLICY IF EXISTS "Allow public read access" ON public.investment_products;
DROP POLICY IF EXISTS "Allow admin access" ON public.action_logs;


-- RLS POLICIES

-- PROFILES Table
CREATE POLICY "Allow all access for admins" ON public.profiles FOR ALL USING (public.is_admin());
CREATE POLICY "Users can view their own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- BALANCES Table
CREATE POLICY "Allow all access for admins" ON public.balances FOR ALL USING (public.is_admin());
CREATE POLICY "Users can view their own balances" ON public.balances FOR SELECT USING (auth.uid() = user_id);

-- TRADES Table
CREATE POLICY "Allow all access for admins" ON public.trades FOR ALL USING (public.is_admin());
CREATE POLICY "Users can view their own trades" ON public.trades FOR SELECT USING (auth.uid() = user_id);

-- REQUESTS Table
CREATE POLICY "Allow all access for admins" ON public.requests FOR ALL USING (public.is_admin());
CREATE POLICY "Users can manage their own requests" ON public.requests FOR ALL USING (auth.uid() = user_id);

-- INVESTMENTS Table
CREATE POLICY "Allow all access for admins" ON public.investments FOR ALL USING (public.is_admin());
CREATE POLICY "Users can view their own investments" ON public.investments FOR SELECT USING (auth.uid() = user_id);

-- REWARD_LOGS Table
CREATE POLICY "Allow all access for admins" ON public.reward_logs FOR ALL USING (public.is_admin());
CREATE POLICY "Users can view their own reward logs" ON public.reward_logs FOR SELECT USING (auth.uid() = user_id);

-- USER_TASK_STATES Table
CREATE POLICY "Allow all access for admins" ON public.user_task_states FOR ALL USING (public.is_admin());
CREATE POLICY "Users can manage their own task states" ON public.user_task_states FOR ALL USING (auth.uid() = user_id);

-- SWAP_ORDERS Table
CREATE POLICY "Allow all access for admins" ON public.swap_orders FOR ALL USING (public.is_admin());
CREATE POLICY "Users can manage their own swap orders" ON public.swap_orders FOR ALL USING (auth.uid() = user_id OR auth.uid() = taker_id);
CREATE POLICY "Users can view open swap orders" ON public.swap_orders FOR SELECT USING (status = 'open');

-- ADMIN-MANAGED "CONTENT" TABLES (with public read access)
CREATE POLICY "Allow admin access to content tables" ON public.daily_tasks FOR ALL USING (public.is_admin());
CREATE POLICY "Allow public read access" ON public.daily_tasks FOR SELECT USING (true);
CREATE POLICY "Allow admin access to content tables" ON public.activities FOR ALL USING (public.is_admin());
CREATE POLICY "Allow public read access" ON public.activities FOR SELECT USING (true);
CREATE POLICY "Allow admin access to content tables" ON public.announcements FOR ALL USING (public.is_admin());
CREATE POLICY "Allow public read access" ON public.announcements FOR SELECT USING (true);
CREATE POLICY "Allow admin access to content tables" ON public.investment_products FOR ALL USING (public.is_admin());
CREATE POLICY "Allow public read access" ON public.investment_products FOR SELECT USING (true);

-- ACTION_LOGS Table (Admin only)
CREATE POLICY "Allow admin access" ON public.action_logs FOR ALL USING (public.is_admin());


-- 8. PUBLICATION FOR REALTIME
-- Drop existing publications if they exist to avoid conflicts.
DROP PUBLICATION IF EXISTS supabase_realtime;

-- Create a new publication for tables that need realtime client-side updates.
CREATE PUBLICATION supabase_realtime FOR TABLE 
    public.market_summary_data, 
    public.market_kline_data, 
    public.swap_orders,
    public.trades,
    public.investments,
    public.balances;


-- 9. CRON JOB FOR SETTLEMENTS
-- Schedule the settlement function to run every minute.
SELECT cron.schedule('settle-due-records-job', '*/1 * * * *', 'SELECT public.settle_due_records()');
